<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Prahlad Yeri's Blog - Software Engineering</title><link href="https://prahladyeri.github.io/" rel="alternate"></link><link href="https://prahladyeri.github.io/feeds/software-engineering.atom.xml" rel="self"></link><id>https://prahladyeri.github.io/</id><updated>2022-09-21T07:50:00+05:30</updated><subtitle>Educate and solve problems is my mantra. I'm skilled in web development and a quick learner, I also like blogging and contributing to open source.</subtitle><entry><title>How to approach and evaluate programming languages for a project</title><link href="https://prahladyeri.github.io/blog/2022/09/how-to-approach-and-evaluate-programming-languages-for-a-project.html" rel="alternate"></link><published>2022-09-21T07:50:00+05:30</published><updated>2022-09-21T07:50:00+05:30</updated><author><name>Prahlad Yeri</name></author><id>tag:prahladyeri.github.io,2022-09-21:/blog/2022/09/how-to-approach-and-evaluate-programming-languages-for-a-project.html</id><summary type="html">&lt;p&gt;While it's a topic which has already invited hair splitting debates ad nauseam, it has also invited a lot of hype and there is a need to unclutter that hype and think about this topic objectively.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Toolbox Approach&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This has been the classic or traditional approach when programming used …&lt;/p&gt;</summary><content type="html">&lt;p&gt;While it's a topic which has already invited hair splitting debates ad nauseam, it has also invited a lot of hype and there is a need to unclutter that hype and think about this topic objectively.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Toolbox Approach&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This has been the classic or traditional approach when programming used to be much simpler in the earlier days! &lt;em&gt;"Right tool for the right job"&lt;/em&gt; used to be the motto once and you never thought of using a hammer when a chisel was needed. Around the early part of this century, languages began to consolidate and the result is that we only have a handful of highly popular ones used in the industry today and the rest are cast away into specialized domains.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Paradigm Approach&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The paradigm approach once was and still is popular today, in fact this is one way of thinking that contributes to the toolbox approach. Procedural languages like C and Rust are naturally built for system programming work or in situations where that last bit of computing performance is needed. The OOP paradigm in languages like C++ and C# helped build most of the desktop world citizens we use today such as operating systems, office suites, internet browsers, IDEs, etc. Python's dynamic nature is similarly suited for data analysis work and PHP's "all paradigms embracing" philosophy once made it a popular choice for web development. Same could be said about JavaScript to some extent, though it's a language choice that's more like thrust upon the web developers instead of being a natural choice! This is a highly subjective view, of course, all kinds of arguments can be made here depending on your own tastes and preferences.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Ecosystem Approach&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is what I consider to be a modern approach of evaluating languages. Programming is no longer simple like it used to be once, today each major language has a comprehensive open source ecosystem built around it, and since these communities collaborate among themselves to not only build redistributable software packages but also help their users on coding forums, etc., they become a very important factor or consideration in taking the decision to use that language itself!&lt;/p&gt;
&lt;p&gt;Consider the strange case of PHP, for instance. It's almost treated like a pariah in many programming circles, you'll find very few courses having PHP in their curriculum and not one major &lt;a href="https://github.com/prahladyeri/CuratedLists/blob/master/lists/programming.md#coding-forums-weblogs-and-discussion-sites"&gt;coding forum, blog or discussion site&lt;/a&gt; has a PHP topic included except Stack Overflow. But still the language is almost entirely powered by its community or ecosystem! It's also a language that pioneered open source development and collaboration by involving contributors on massive scales with projects like Wordpress, Drupal, Joomla, Laravel, etc. which have all become ecosystems in their own right.&lt;/p&gt;
&lt;p&gt;A technology startup which is already hard-pressed in today's economically stressing times will obviously want to leverage the power of open source software and free tools, and that's where the ecosystem comes into picture! How friendly is the community on discussion forums and how large is the package ecosystem are typically the top questions in the minds of technology startup entrepreneurs.&lt;/p&gt;
&lt;p&gt;In this regard, Python, PHP and JavaScript are the major champion ecosystems and perhaps top the list of usage surveys, they've developed elaborate package management systems to serve their bases - PyPi, Composer and npm respectively. This trend has caught to some extent in the C# and Java world too with nuget and gradle/maven but theirs seem to cater to mostly the enterprise world, there doesn't seem to be the same kind of buzz among the startups for these languages.&lt;/p&gt;
&lt;p&gt;Summarily, these are the three major approaches for evaluating a programming language. There are others too, a major one being local availability of professionals skilled in a language. But in the age of remote working, I'm hoping that factor should become less important as time progresses. And there are "contrarian coders" too who will invest in learning long obsolete languages like COBOL and FORTRAN hoping that the skewed supply/demand ratio for these skills arising due to the need for maintaining legacy systems will ensure they get hired with handsome perks. Indeed, that's an approach or way of looking at things too!&lt;/p&gt;</content><category term="Programming"></category><category term="PHP"></category><category term="Python"></category><category term="OOP"></category></entry><entry><title>Agile manifesto is problematic</title><link href="https://prahladyeri.github.io/blog/2019/07/agile-manifesto-is-problematic.html" rel="alternate"></link><published>2019-07-02T11:40:00+05:30</published><updated>2019-07-02T11:40:00+05:30</updated><author><name>Prahlad Yeri</name></author><id>tag:prahladyeri.github.io,2019-07-02:/blog/2019/07/agile-manifesto-is-problematic.html</id><summary type="html">&lt;p&gt;After reading the &lt;a href="https://agilemanifesto.org"&gt;agile manifesto&lt;/a&gt;, I felt like it is too one-sided and imbalanced, it gives too much importance to some aspects of software development and belittles the other.&lt;/p&gt;
&lt;p&gt;The stuff they give prominence to isn't any extraordinary new age rocket science (though the practitioners of agile try very hard …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After reading the &lt;a href="https://agilemanifesto.org"&gt;agile manifesto&lt;/a&gt;, I felt like it is too one-sided and imbalanced, it gives too much importance to some aspects of software development and belittles the other.&lt;/p&gt;
&lt;p&gt;The stuff they give prominence to isn't any extraordinary new age rocket science (though the practitioners of agile try very hard to pretend like that!). Its just some basic common sense stuff such as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Working software over comprehensive documentation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Should it really take a genius to tell you that? The working software funda has been going on since Windows-95 (and even earlier), long before these agile pundits had started going to their schools. I never had to read a single line of documentation when I started using Windows-95 for the first time.&lt;/p&gt;
&lt;p&gt;Even before Windows-95, they invented the concept of &lt;code&gt;man pages&lt;/code&gt; in Unix which allowed for component specific documentation (manuals) to be embedded as an addon to Unix itself. And this happened in Bell Labs way back in 1960s, long before these modern agile pundits were even born!&lt;/p&gt;
&lt;p&gt;Coming to the second point, the stuff that agile tries to discard and throw away are some hard learned lessons which helped the humankind to reach the industrial age.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Individuals and interactions over processes and tools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Again, nobody is denying the importance of human interaction, its a basic common sense thing that humans have been doing since the stone age and will continue doing till eternity. But belittling processes and tools? That's preposterous! If anything is preventing the modern economic and banking system from falling apart, its processes and tools. If the growth of top MNC companies and the industrial revolution is still continuing to hold, its again thanks to processes and tools. Without processes and tools, humanity is back into the stone age (or perhaps the bronze age, but doesn't really matter).&lt;/p&gt;
&lt;p&gt;The point is that both human interaction and processes have their importance in economic growth and development, and more importantly, this is a very basic or common knowledge at this point, we don't need agile pundits to teach us these basic things.&lt;/p&gt;
&lt;p&gt;Yet another gem from agile enthusiasts:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Customer collaboration over contract negotiation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Can you even imagine this to be an X versus Y thing! Collaboration with the client and negotiation of an IT contract are totally different aspects of the business and both are important.&lt;/p&gt;
&lt;p&gt;The former is mostly technical and happens between the programmers/designers on outsourcing company's side, and the users on the client side. Whereas the latter happens between sales and procurement heads of the outsourcing and client companies respectively (in some rare cases, the CFO/CEO may be involved).&lt;/p&gt;
&lt;p&gt;Again, a very basic thing which should be in the first year MBA syllabus! Now, let's expose the final aphorism of the agile pundits.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Responding to change over following a plan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As I've recently written about this in a &lt;a href="https://dev.to/prahladyeri/forget-agile-and-kanban-understand-what-your-user-wants-first-2pjn"&gt;DEV.to article&lt;/a&gt;, the agile enthusiasts always live in the delusion that software was never made in a dynamic or changing environment before they started treading this planet. The iterative model, a variation of water-fall model of development, was practiced since decades before the agile wisdom was being sprouted by these people.&lt;/p&gt;
&lt;p&gt;All in all, the agile manifesto brings nothing new to the table and desperately tries to present the already proven conventional wisdom and common sense things as if they were a new concept or methodology they've invented from scratch. This is just absurd and ridiculous, and people shouldn't fall in their trap.&lt;/p&gt;</content><category term="Architecture"></category><category term="Productivity"></category></entry></feed>