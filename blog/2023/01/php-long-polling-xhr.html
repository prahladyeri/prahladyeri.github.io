<!DOCTYPE html>
<html lang="en">
<head>
  	<meta charset="utf-8" />
	<title>How to handle long-polling of XHR requests in PHP</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" property="og:description" content="A common need you often face in PHP scripting these days is writing a long-polling endpoint for things like sending notifications or other kinds of responses back to the client. While using something dedicated like node, cometd or websocket makes ideal sense for such things, there are use-cases when you …">
	<link rel="canonical" content="https://prahladyeri.github.io/blog/2023/01/php-long-polling-xhr.html" />
	<meta name="author" content="Prahlad Yeri">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
	<link rel="stylesheet" href="/theme/css/app.css?v=1.3">
	<link rel="stylesheet" href="/theme/css/pygment.css">		
	<link rel="shortcut icon" type="image/x-icon" href="/uploads/py.png" />
	<link href="https://prahladyeri.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Prahlad Yeri's Blog Full Atom Feed" />
	<link href="https://prahladyeri.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Prahlad Yeri's Blog Full RSS Feed" />
	<link href="https://prahladyeri.github.io/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Prahlad Yeri's Blog Categories Atom Feed" />




    <meta name="tags" content="XHR" />
    <meta name="tags" content="Apache" />
    <meta name="tags" content="CodeIgniter" />

	
	
	
	<!-- twitter card meta data -->
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:site" content="@prahladyeri" />
	<meta name="twitter:creator" content="@prahladyeri" />
		<meta name="twitter:url" content="https://prahladyeri.github.io/blog/2023/01/php-long-polling-xhr.html" />
		<meta name="twitter:title" content="How to handle long-polling of XHR requests in PHP" />
		<meta name="twitter:description" content="A common need you often face in PHP scripting these days is writing a long-polling endpoint for things like sending notifications or other kinds of responses back to the client. While using something dedicated like node, cometd or websocket makes ideal sense for such things, there are use-cases when you …" />
			<meta name="twitter:image" content="https://prahladyeri.github.io/uploads/php-xhr-long-polling.png" />
			<meta name="image" property="og:image" content="https://prahladyeri.github.io/uploads/php-xhr-long-polling.png">

	
	
<!--pinterest claim-->
<meta name="p:domain_verify" content="eb43d46309e2766ef1b627cea2d19326"/>
</head>

<body>
<div id='header'>
<div class='text-center' >
	<h1 style='color:darkseagreen'>Prahlad Yeri</h1>
	<h4  style='color:grey;'>Freelance Programmer and Writer</h4>
</div>

<div id='navBlock' class='text-center' >
	<a class="nav-link" href="/">Home</a> | 
	<a class="nav-link" href="/blog">Blog</a> | 
	<a class="nav-link" href="/portfolio">Portfolio</a> | 
	<a class="nav-link" href="https://github.com/prahladyeri/resume">Resume</a> | 
	<a class="nav-link" href="/hire-me">Hire Me</a>
	<br>
	Social:
	<a class="nav-link" href="https://twitter.com/prahladyeri">Twitter</a> | 
	<a class="nav-link" href="https://github.com/prahladyeri">Github</a> | 
	<a class="nav-link" href="https://www.linkedin.com/in/prahlad-yeri-243a5316">Linkedin</a> | 
	<a class="nav-link" href="https://prahladyeri.medium.com/">Medium</a> | 
	<a class="nav-link" href="https://www.quora.com/profile/Prahlad-Yeri">Quora</a>
	<br>
	Email: prahladyeri at yahoo dot com | 
	Feeds:
	<a class="nav-link" href="/feeds/all.rss.xml">RSS</a> | 
	<a class="nav-link" href="/feeds/all.atom.xml">ATOM</a>
</div>
</div>
<div id="main" class='row content '>
<div class='col w50 m-auto'>
<section id="content" class="body">
  <header>
	<h1 style='color: darkolivegreen;' class='mt-4 mb-4'>How to handle long-polling of XHR requests in PHP</h1>
 
  </header>
  <footer class="post-info clearfix">
	<span class='float-left'>
    <time class="text-muted published" datetime="2023-01-02T17:50:00+05:30">Mon 02 January 2023</time>
    <div class="text-muted vcard author">
      By           <a class="url fn" href="https://prahladyeri.github.io/">Prahlad Yeri</a>
    </div>
	</span>
	<div class='float-right'>
    <div class="text-muted category text-right">
        Filed under <a href="https://prahladyeri.github.io/blog/category/php">PHP</a>
    </div>
    <div class="text-muted tags">
		Tags
            <a href="https://prahladyeri.github.io/blog/tag/xhr">XHR</a>
            <a href="https://prahladyeri.github.io/blog/tag/apache">Apache</a>
            <a href="https://prahladyeri.github.io/blog/tag/codeigniter">CodeIgniter</a>
    </div>
	</div>
  </footer><!-- /.post-info -->
  
  <div class="entry-content">
    <p>A common need you often face in PHP scripting these days is writing a long-polling endpoint for things like sending notifications or other kinds of responses back to the client. While using something dedicated like node, cometd or websocket makes ideal sense for such things, there are use-cases when you want to accomplish this in PHP itself and don't want to add any extra dependencies or components to your project.</p>
<p><img alt="php xhr long polling" src="/uploads/php-xhr-long-polling.png"></p>
<p>In this post, I'll show you how to achieve this to a limited extent in PHP. But how scalable this solution will be will depend on the threading model and configuration of your web-server (apache/nginx). The basic problem with long-polling is that unlike short-polling, the client won't exit immediately. The client keeps waiting for a response and this will inevitably block a thread on your web server. The same principle applies even when you go for other solutions like websocket, cometd, etc. but these libraries or components hide this "wait" implementation away from your code.</p>
<p>A notable exception here is node.js. Due to its uniquely architectured single-threaded event based model, this problem isn't faced. Anyway, coming back to PHP implementation, here is how I handled it in my code. Please note that it's extremely important to call <code>session_write_close()</code> as early as possible in your code and it's also important to override the default <code>max_execution_time</code> php configuration at the beginning of your php script or framework configuration with something like this:</p>
<div class="highlight"><pre><span></span><span class="x">ini_set(&#39;max_execution_time&#39;, &#39;300&#39;);</span>
</pre></div>


<p>Once you ensure this, this is how you can handle it on php side:</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">fetch_long</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">session_write_close</span><span class="p">();</span>
    <span class="nb">error_log</span><span class="p">(</span><span class="s1">&#39;LONG POLLING&#39;</span><span class="p">);</span>
    <span class="nv">$start</span> <span class="o">=</span> <span class="nb">time</span><span class="p">();</span>
    <span class="nb">error_log</span><span class="p">(</span><span class="s2">&quot;LONG POLLING LOOP STARTS...&quot;</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="nb">time</span><span class="p">()</span><span class="o">-</span><span class="nv">$start</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">300</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">&quot;select * from notifications where id=1&quot;</span><span class="p">;</span>
        <span class="nb">error_log</span><span class="p">(</span><span class="s2">&quot;NOW QUERYING...&quot;</span><span class="p">);</span>
        <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">db</span><span class="o">-&gt;</span><span class="na">query</span><span class="p">(</span><span class="nv">$sql</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">result_array</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">count</span><span class="p">(</span><span class="nv">$r</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">error_log</span><span class="p">(</span><span class="s2">&quot;GOT NOTIFS, ESCAPING...&quot;</span><span class="p">);</span>
            <span class="k">echo</span> <span class="nb">json_encode</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">error_log</span><span class="p">(</span><span class="s2">&quot;I KEEP POLLING ...&quot;</span><span class="o">.</span><span class="p">(</span><span class="nb">time</span><span class="p">()</span><span class="o">-</span><span class="nv">$start</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="nb">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nb">error_log</span><span class="p">(</span><span class="s2">&quot;ESCAPING ANYWAY...&quot;</span><span class="p">);</span>
    <span class="k">echo</span> <span class="nb">json_encode</span><span class="p">([]);</span>
<span class="p">}</span>
</pre></div>


<p>Please note that once you call <code>session_write_close()</code>, you won't be able to write to any session variables. However, you'll still be able to read them. What I then do is create a blocking loop with a maximum limit of 300 seconds (you can increase it to as much as you want subject to what value you configured in <code>max_execution_time</code> earlier). If a notification is fetched before that time, I simply return it and exit the function. If not, the loop just times out in the end and I return a blank array.</p>
<p>Finally, this is how my AJAX call on front-end looks:</p>
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">fetchNotifications</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">url</span><span class="o">:</span> <span class="s2">&quot;/home/fetch_long&quot;</span><span class="p">,</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;GET&#39;</span><span class="p">,</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nx">error</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">fetchNotifications</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">handleNotif</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
            <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">fetchNotifications</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">fetchNotifications</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>


<p>Once the client receives a response from server, it keeps calling it again and again ad-infinitum to keep fetching the notifications.</p>
<p>The obvious limitation of this method is that a thread is blocked for every "waiting" request on the server side, so it isn't ideal for scaling. In my case, I had only 30-40 users at most who used this app, so it wasn't a big issue. Even then, I've added a pause of 3 seconds on client side before making the next request, just so as to give some breathing space to the server.</p>
<p>Despite the limitation, the app is working decently on the apache server without any configuration tweaks required. And besides, this is an architectural limitation which will always be there as I said, even in case of third party solutions like cometd and websocket.</p>
<p>Were you able to scale your PHP app with long polling by using this method? Please comment and let me know.</p>
  </div><!-- /.entry-content -->

	<!-- Start: Prahlad -->
	<script>
	$(document).ready(function(){
		$(".entry-content table").addClass("table table-bordered table-sm");
		$(".entry-content img").parent().css({'text-align': 'center'});
	});
	</script>

	<!--start: adsense-->
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0428291735937735"
     crossorigin="anonymous"></script>
	<!-- prahladyeri.github.io -->
	<ins class="adsbygoogle"
		 style="display:block"
		 data-ad-client="ca-pub-0428291735937735"
		 data-ad-slot="9729062115"
		 data-ad-format="auto"
		 data-full-width-responsive="true"></ins>
	<script>
	(adsbygoogle = window.adsbygoogle || []).push({});
	</script>
	<!--end: adsense-->
	
	
	
	<!-- End: Prahlad -->
</section>
</div>
</div>


<footer id ="footer" class="text-center">
Copyright (&copy;) 2014-2022 Prahlad Yeri.<br>This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</footer>

</body>
</html>